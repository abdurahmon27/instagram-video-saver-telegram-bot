"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const moment_1 = __importDefault(require("moment"));
const Fetch_1 = __importDefault(require("./Fetch"));
const BASE_URL = `https://api.telegram.org`;
class TelegramApi {
    /**
     * constructor
     * @param teletramToken: string;
     * @paran options?: ITelegramApiProps
     * @return void
     */
    constructor(teletramToken, options) {
        this.SERIES = "series"; // 직렬
        this.PARALLEL = "parallel"; // 병렬
        this.pollingArguments = [];
        this.options = {};
        this.messageQueue = [];
        this.getUpdatesUrl = `${BASE_URL}/bot${teletramToken}/getUpdates`;
        this.sendMessageUrl = `${BASE_URL}/bot${teletramToken}/sendMessage`;
        this.deleteMessageUrl = `${BASE_URL}/bot${teletramToken}/deleteMessage`;
        (() => __awaiter(this, void 0, void 0, function* () {
            this.setLastMessageId(yield this.getLastUpdateMessageId());
            if (options === null || options === void 0 ? void 0 : options.polling) {
                yield this.startPolling(options);
            }
        }))();
    }
    /**
     * init
     * @param callback: initCallbackType
     */
    init(callback) {
        if (typeof callback === "function") {
            callback(this.options);
        }
    }
    /**
     * getOptions
     */
    getOptions() {
        return this.options;
    }
    /**
     * pushMessageQueue
     * @param chatId: number 메시지받을 사람의 chat_id
     * @param message: string 메시지 내용
     */
    pushMessageQueue({ chatId, message }) {
        this.messageQueue.push({ chatId, message });
    }
    /**
     * callMessageQueue
     * 메시지큐에 들어가있는 메시지를 처음 들어가있는 순서대로 발송한다.
     */
    callMessageQueue() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this.messageQueue.length > 0) {
                const queue = this.messageQueue.shift();
                if (queue) {
                    yield this.sendMessage(queue.chatId, queue.message);
                    // sleep 1초
                    yield this.sleep(1000);
                }
            }
        });
    }
    /**
     * startPolling
     * @param options: ITelegramApiProps
     */
    startPolling(options) {
        return __awaiter(this, void 0, void 0, function* () {
            while (options.polling) {
                const arrResult = yield this.getUpdates();
                if (arrResult) {
                    if (options.process === this.SERIES) {
                        // 메시지 직렬방식으로 처리
                        yield this.pollSeriesJob(arrResult);
                    }
                    else {
                        // 메시지 병렬방식으로 처리(default)
                        yield this.pollParallelJob(arrResult);
                    }
                }
                // sleep 1초
                yield this.sleep(1000);
                this.callMessageQueue();
            }
        });
    }
    /**
     * pollParallelJob
     * 메시지 병렬처리
     * @param arrResult: IResultProps[]
     */
    pollParallelJob(arrResult) {
        return __awaiter(this, void 0, void 0, function* () {
            arrResult.forEach((item) => __awaiter(this, void 0, void 0, function* () {
                yield this.pollJob(item);
            }));
        });
    }
    /**
     * pollSeriesJob
     * 메시지 직렬처리
     * @param arrResult: IResultProps[]
     */
    pollSeriesJob(arrResult) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const item of arrResult) {
                yield this.pollJob(item);
            }
        });
    }
    /**
     * pollJob
     * 메시지 처리
     * @param item: IResultProps
     */
    pollJob(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (item.message) {
                // 일반 메시지 콜백처리
                yield this.callTextMessage(item.message);
            }
            else if (item.callback_query) {
                // 채팅창의 버튼클릭시 콜백처리
                yield this.callCallbackMessage(item.callback_query);
            }
        });
    }
    /**
     * callTextMessage
     * 채팅창에 일반메시지 입력되었을때 콜백처리
     * @param message: IMessage
     */
    callTextMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const { message_id, chat: { id }, from: { is_bot }, text, } = message;
            if (!is_bot) {
                yield this.callCallback("text", {
                    chatId: id,
                    messageId: message_id,
                    text,
                });
            }
        });
    }
    /**
     * callCallbackMessage
     * 채팅창에 생성된 버튼을 클릭하였을때 콜백처리
     * @param callback_query: ICallbackProps
     */
    callCallbackMessage(callback_query) {
        return __awaiter(this, void 0, void 0, function* () {
            // 채팅창의 버튼클릭시 콜백처리
            const { message: { message_id, chat: { id }, text, }, data, } = callback_query;
            yield this.callCallback("callback", {
                chatId: id,
                messageId: message_id,
                text,
                data,
            });
        });
    }
    /**
     * on 이벤트리스너에 등록된 콜백함수 호출
     */
    callCallback(listener, { chatId, messageId, text, data }) {
        return __awaiter(this, void 0, void 0, function* () {
            const callback = this.getPollingCallback(listener);
            if (typeof callback === "function") {
                yield callback({
                    chatId,
                    messageId,
                    text,
                    data,
                    options: this.options,
                });
            }
        });
    }
    /**
     * getPollingCallback
     * listener에 등로된 콜백함수를 리턴
     * @param listener: "text" | "callback"
     * @return (param: IPollingCallbackProps) => Promise<void>
     */
    getPollingCallback(listener) {
        return this.pollingArguments.filter((value) => value.listener === listener)[0].callback;
    }
    /**
     * isPollingListener
     * 이미 listener에 등록되어있는지 체크한다.
     * @param listener: "text" | "callback"
     * @return boolean
     */
    isPollingListener(listener) {
        return this.pollingArguments.some((value) => value.listener === listener);
    }
    /**
     * on
     * @param listener: listenerType
     * @param callback: callbackType
     */
    on(listener, callback) {
        const isExists = this.isPollingListener(listener);
        !isExists && this.pollingArguments.push({ listener, callback });
    }
    watch(watchCallback, delay = 1000) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof watchCallback === "function") {
                while (true) {
                    yield watchCallback({ options: this.options });
                    yield this.sleep(delay);
                }
            }
        });
    }
    /**
     * 채팅방 메시지 받아오기
     */
    getUpdates() {
        return __awaiter(this, void 0, void 0, function* () {
            let url = this.getUpdatesUrl;
            if (this.lastUpdateMessageId) {
                url = `${url}?offset=${this.lastUpdateMessageId + 1}`;
            }
            const res = yield Fetch_1.default.get(url, 5000);
            if (res) {
                const { data: { ok, result }, } = res;
                // console.log(result);
                if (ok) {
                    this.setLastMessageId(this.getLastMessageId(result));
                    return result;
                }
            }
            return;
        });
    }
    /**
     * 메시지 보내기
     * @param chatId: number
     * @param message: string
     * @param parse_mode?: string
     */
    sendMessage(chatId, message, parse_mode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Fetch_1.default.post(this.sendMessageUrl, {
                chat_id: chatId,
                text: message,
                parse_mode,
            }, 5000);
        });
    }
    /**
     * inline button 메시지 보내기
     * @param chatId: number
     * @param message: string
     * @param inlineButton: IInlineButton[][]
     * @param parse_mode?: string
     */
    sendInlineButtonMessage(chatId, message, inlineButton, parse_mode) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Fetch_1.default.post(this.sendMessageUrl, {
                chat_id: chatId,
                text: message,
                parse_mode,
                reply_markup: JSON.stringify({ inline_keyboard: inlineButton }),
            }, 5000);
        });
    }
    /**
     * inline button 메시지 보내기
     * @param chatId: number
     * @param  message: string
     * @param  keyboard: string[][]
     */
    sendKeyboardMessage(chatId, message, keyboard) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Fetch_1.default.post(this.sendMessageUrl, {
                chat_id: chatId,
                text: message,
                parse_mode: "MarkDown",
                reply_markup: JSON.stringify({
                    keyboard: keyboard,
                    resize_keyboard: true,
                }),
            }, 5000);
        });
    }
    /**
     * 메시지 삭제하기
     * @param chatId: number
     * @param messageId: number
     */
    deleteMessage(chatId, messageId) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Fetch_1.default.post(this.deleteMessageUrl, {
                chat_id: chatId,
                message_id: messageId,
            }, 5000);
        });
    }
    /**
     * 채팅방 마지막 메시지번호 가져오기
     */
    getLastUpdateMessageId() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield Fetch_1.default.get(this.getUpdatesUrl, 5000);
            if (res) {
                const { data: { ok, result }, } = res;
                if (ok) {
                    if (result.length > 0) {
                        return result[result.length - 1].update_id;
                    }
                }
            }
            return;
        });
    }
    /**
     * 텔레그램 마지막 메시지ID를 가져온다.
     * @param result: IResultProps[]
     */
    getLastMessageId(result) {
        if (result.length > 0) {
            return result[result.length - 1].update_id;
        }
    }
    /**
     * 텔레그램 마지막 메시지ID를 등록한다.
     * @param updateId?: number
     */
    setLastMessageId(updateId) {
        if (updateId &&
            (!this.lastUpdateMessageId || this.lastUpdateMessageId < updateId)) {
            this.lastUpdateMessageId = updateId;
        }
    }
    /**
     * sleep
     * @param ms: number
     */
    sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
    }
    /**
     * sleep
     * @param msg: any
     */
    asyncLog(msg) {
        return new Promise((resolve) => {
            console.log(moment_1.default().format("YYYY-MM-DD HH:mm:ss"), msg);
            return resolve("");
        });
    }
}
exports.default = TelegramApi;
//# sourceMappingURL=index.js.map